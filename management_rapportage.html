<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TwiQel - Management rapportage bezetting en benutting onderwijsruimtes</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <style>

    </style>
</head>

<body>
    <div class="tabs">
        <button class="tablink active" onclick="openTab('description')">Beschrijving</button>
        <button class="tablink" onclick="openTab('bezetting')">Bezetting</button>
        <button class="tablink" onclick="openTab('benutting')">Benutting</button>
        <button class="tablink" onclick="openTab('filter')">Filter Tool</button>
        <button class="tablink" onclick="openTab('roostergraad')">Roostergraad</button>
    </div>
    <div class="container">
        <!-- <div class="topbar"> -->
            <!-- <a href="/"><img src="logo.svg" alt="Logo" class="logo"></a> -->
            <!-- <h1>Management rapportage bezetting en benutting onderwijsruimtes</h1> -->
        <!-- </div> -->
        <!-- <br><br> -->
        <input type="file" id="csvFileInput" accept=".csv">
        <!-- we add a button to run the csv -->
        <button id="runButton">Run</button>


        <div class="rapport-container">
            <div class="time-option">
                <label>
                    <input type="radio" name="timeRange" value="full" checked>
                    Gebruik tijden tussen 7:00 and 22:00
                </label>
                <label>
                    <input type="radio" name="timeRange" value="limited">
                    Gebruik tijden tussen 8:00 and 18:00
                </label>
            </div>

            <!-- Tabs Navigation -->



            <!-- Tab Content -->
            <div id="description" class="tab active">


 
    
                <div id="summary">
                    <h2>1. Beschrijving brondata van bezetting en benutting onderwijsruimtes</h2>
                    <p id="summaryText"></p>
                </div>
                <div id="measurements-table"></div>
                <figure>
                    <figcaption>Figure I: Aantal meetmomenten per zaal gedurende <span id="measurement-days"></span>
                        werkdagen</figcaption>
                </figure>
                <h2>2.1 Bezetting onderwijsruimtes</h2>
                <div id="bezetting-table"></div>
                <figure>
                    <figcaption>Figure II: Bezetting per kwartier per onderwijsruimte, gemeten over <span
                            id="first-meas-date"></span> t/m <span id="last-meas-date"></span></figcaption>
                </figure>
    
                <p>Gemiddeld zijn de <span id="room-count"></span> onderwijsruimtes <span id="average-occupancy"></span> van
                    de tijd bezet.</p>
                HIER NOG EEN LIJSTJE MET MEEST EN MINST BEZETTE RUIMTES
    
                <br><br>
                <p style="color: red;">Hier onder een voorbeeldje van hoe de data per ruimte er uit gaat zien. Ik handel
                    gevallen die over de capaciteit zitten nog niet goed, en ik heb nog niet gevalideerd of het allemaal
                    klopt, dat ga ik binnenkort doen. Er moet ook nog een dikkere rand om de twee catagorieen. Wellicht is
                    het ook beter om 1 grote tabel te maken ipv een boel kleine, dit is wel een beetje cluttered.</p>
                <div id="roomTables"></div>
                        </div>

            <div id="bezetting" class="tab">
                <h2>2.1 Bezetting onderwijsruimtes</h2>
                <div class="allPlots">
                    <!-- <div id="throughout-day-plot" class="plot"></div>
                    <div id="throughout-weekday-plot" class="plot"></div> -->
                    <div id="throughout-day-plot-rooms" class="plot"></div>
                    <div id="throughout-weekday-plot-rooms" class="plot"></div>
                </div>
            </div>

            <div id="benutting" class="tab">
                <h2>Benutting onderwijsruimtes</h2>
                <div class="allPlots">
                    <div id="throughout-day-plot-rooms-benutting" class="plot"></div>
                    <div id="throughout-weekday-plot-rooms-benutting" class="plot"></div>
                </div>
                <!-- <div id="throughout-day-plot-rooms-benutting"></div>
                <br><br>
                <div id="throughout-weekday-plot-rooms-benutting"></div> -->
            </div>
            <div id="roostergraad" class="tab">
                <h2>Roostergraad onderwijsruimtes</h2>
                    <div style="width: 70%;">
                        <div id="rooster-graad-plot" class="plot"></div>
                    </div>
                    <!-- <div id="throughout-weekday-plot-rooms-roostergraad" class="plot"></div> -->
            </div>
            <div id="filter" class="tab">
                <h2>Filter tool!</h2>
                <div class="filter-tool">
                    <div class="allPlots">
                        <div id="plot0" class="plot"></div>
                        <div id="plot1" class="plot"></div>
                        <div id="plot2" class="plot"></div>
                        <div id="plot3" class="plot"></div>
                    </div>
                    <footer>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4472c4;"></div>
                            Wel geroosterd & bezet
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #ed7d31;"></div>
                            Wel geroosterd & niet bezet
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #a5a5a5;"></div>
                            Niet geroosterd & wel bezet
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #ffc000;"></div>
                            Niet geroosterd & niet bezet
                        </div>
                    </footer>                </div>
            </div>
        </div>

        <script>


            function openTab(tabName) {
                var i, tabcontent, tablinks;
                tabcontent = document.getElementsByClassName("tab");
                for (i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].classList.remove("active");
                }
                tablinks = document.getElementsByClassName("tablink");
                for (i = 0; i < tablinks.length; i++) {
                    tablinks[i].classList.remove("active");
                }
                document.getElementById(tabName).classList.add("active");
                event.currentTarget.classList.add("active");

                // ugly solution to get the plots to fit in the tab
                plotsInTab = document.getElementById(tabName).querySelectorAll('.plot');
                plotsInTab.forEach(plot => Plotly.Plots.resize(plot));
                // Plotly.Plots.resize(document.getElementById(tabName));
            }


            let types = ["rooms", "times", "days", "weekdays"];
            let layouts = {};
            types.forEach(type => layouts[type] = {});

            let all_days_of_week = ["Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag","Zondag"];
            let data;
            let selected = [[], [], [], []];
            let selectedPointsByPlot = [[], [], [], []];
            limitedTimeRangeStart = 8;
            limitedTimeRangeEnd = 18;
            function reapplySelection(plotIndex) {
                const plotDiv = document.getElementById('plot' + plotIndex);
                const selectedIndices = selectedPointsByPlot[plotIndex];
                const selectedpointsArray = new Array(plotDiv.data.length).fill(null).map(() => selectedIndices);
                Plotly.restyle(plotDiv, { selectedpoints: selectedpointsArray });
            }

            function handleSelection(event, plotIndex) {

                const selectedPoints = event.points;
                if (selectedPoints.length > 0) {
                    const selectedKeys = selectedPoints.map(point => point.x);
                    selected[plotIndex] = [...new Set(selectedKeys)].sort(); // there's 4 bars, so take uniques to reduce filter time (less points to compare)
                    selectedPointsByPlot[plotIndex] = selectedPoints.map(point => point.pointIndex);

                    allTraces = data2traces(data);

                    types.forEach((type, i) => {
                        Plotly.react('plot' + i, allTraces[type], layouts[type],{responsive: true}); // there's also Plotly.update, but I couldn't get it to work, possibly more efficient
                        if (selected[i].length > 0) {
                            reapplySelection(i);
                        }
                    })
                }
            }

            let measurementDays;
            const roomNamesSet = new Set(); // To collect unique room names
            document.getElementById('runButton').addEventListener('click', function () {
                const fileInput = document.getElementById('csvFileInput');
                const file = fileInput.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const contents = e.target.result;
                        data = parseCSV(contents);
                        processCSV();
                    };
                    reader.readAsText(file);
                }
            });
            document.getElementById('csvFileInput').addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const contents = e.target.result;
                        data = parseCSV(contents);
                        processCSV();
                    };
                    reader.readAsText(file);
                }
            });

            function parseCSV(contents) {
                const lines = contents.split('\n').map(line => line.trim()).filter(line => line);
                const headers = lines[0].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                const rows = lines.slice(1).map(line => {
                    const row = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                    return row.map(cell => cell.replace(/^"|"$/g, '').replace(/""/g, '"'));
                });

                return rows.map(row => {
                    let obj = {};
                    headers.forEach((header, index) => {
                        obj[header] = row[index];
                    });
                    return obj;
                });
            }


            function parseDate(dateStr) {
                const [day, month, year, hour, minute] = dateStr.split(/[- :]/).map(Number);
                return new Date(year, month - 1, day, hour, minute);
            }

            function processCSV() {
                data.forEach(row => {
                    row.DateTime = parseDate(row.DateTime);
                    row.Time = row.DateTime.toTimeString().split(" ")[0]; // Extract time from Date
                    row.EventDay = row.DateTime.toISOString().split('T')[0]; // YYYY-MM-DD format
                    // modulo to make monday first day of week
                    row.weekday = all_days_of_week[(row.DateTime.getDay()+6)%7];
                    row.hour = parseInt(row.Time.split(":")[0]);
                    // row.hour = toIn(row.DateTime.getHours());

                    roomNamesSet.add(row.RoomName); // Add room name to the set
                    // console.log(row.Time)

                });

                data = data.filter(row => {
                    const hour = row.DateTime.getHours();
                    return hour >= 7 && hour < 22; // Keep rows between 7 AM and 10 PM
                })

                // Process and display the tables

                generateTables();

                generateAllLineBezettingPlots();
                generateAllLineBenuttingPlots();
                generateRoosterGraadFigure();

                document.querySelector(".rapport-container").style.display = "block";

                let traces = data2traces(data);
                plot(traces);
            }

            function writeSummary() {
                const totalRooms = roomNamesSet.size; // Total unique room names
                const totalDays = measurementDays; // Assuming you have fixed days, can be calculated based on date range
                let hoursPerDay

                const timeRange = document.querySelector('input[name="timeRange"]:checked').value;
                if (timeRange === 'full') {
                    hoursPerDay = 15
                    start = "7:00"
                    end = "22:00"
                }
                else {
                    hoursPerDay = 8
                    start = limitedTimeRangeStart+":00"
                    end = limitedTimeRangeEnd+":00"
                }

                const measurementsPerHour = 4; // Assuming 4 measurements per hour

                // Calculate total measurements per room
                const totalMeasurementsPerRoom = Math.round(hoursPerDay * measurementsPerHour * totalDays);
                const totalMeasurements = totalRooms * totalMeasurementsPerRoom;

                // Update the summary text
                const summaryText = `
        Voor deze rapportage is de volgende data geselecteerd:
        • ${totalRooms} zalen: ${Array.from(roomNamesSet).join(', ')}.
        • Metingen over ${totalDays} dagen.
        • Metingen tussen ${start} en ${end} uur.
        • Totaal: ${hoursPerDay} uur per dag * ${measurementsPerHour} metingen per uur * ${totalDays} dagen = ${totalMeasurementsPerRoom} opkomstcijfers per zaal over ${totalDays} weken.
    `;
                document.getElementById('summaryText').innerText = summaryText;

            }

            function generateTables() {
                const allRooms = {};
                const measurementDates = [];
                const timeRange = document.querySelector('input[name="timeRange"]:checked').value;


                data.forEach(entry => {
                    const room = entry.RoomName;
                    measurementDates.push(entry.DateTime);

                    // Filtering based on selected time range
                    const hour = entry.DateTime.getHours();
                    if ((timeRange === 'full' && (hour >= 7 && hour < 22)) ||
                        (timeRange === 'limited' && (hour >= limitedTimeRangeStart && hour < limitedTimeRangeEnd))) {
                        if (!allRooms[room]) {
                            allRooms[room] = { measurements: 0, bezet: 0, capacity: entry.RoomCapacity };
                        }
                        allRooms[room].measurements += 1;
                        if (entry.Amount > 0) {
                            allRooms[room].bezet += 1;
                        }
                    }
                });




                const roomsMeasurements = Object.keys(allRooms).map(room => ({ room, measurements: allRooms[room].measurements }));
                const occupancyData = Object.keys(allRooms).map(room => ({ room, ...allRooms[room] }));

                // Generate and display tables
                const measurementsTable = generateMeasurementsTable(roomsMeasurements);
                const bezettingTable = generateOccupancyTable(occupancyData);

                document.getElementById('measurements-table').innerHTML = measurementsTable;
                document.getElementById('bezetting-table').innerHTML = bezettingTable;

                // Setting measurement dates
                const firstDate = new Date(Math.min(...measurementDates));
                const lastDate = new Date(Math.max(...measurementDates));
                measurementDays = Math.round((lastDate - firstDate) / (1000 * 60 * 60 * 24));

                writeSummary();

                document.getElementById('measurement-days').innerText = measurementDays;
                document.getElementById('first-meas-date').innerText = firstDate.toLocaleDateString('nl-NL');
                document.getElementById('last-meas-date').innerText = lastDate.toLocaleDateString('nl-NL');
                document.getElementById('room-count').innerText = Object.keys(allRooms).length;

                const averageOccupancy = ((occupancyData.reduce((sum, item) => sum + item.bezet, 0) / occupancyData.reduce((sum, item) => sum + item.measurements, 0)) * 100).toFixed(0) + '%';
                document.getElementById('average-occupancy').innerText = averageOccupancy;

                const roomTablesDiv = document.getElementById('roomTables');
                roomTablesDiv.innerHTML = ""

                // ============================ per room stats
                Object.keys(allRooms).forEach((room, index) => {
                    const timeRange = document.querySelector('input[name="timeRange"]:checked').value;


                    const filteredData = data.filter(entry => {
                        const hour = entry.DateTime.getHours();

                        return entry.RoomName === room && (timeRange === 'full' && (hour >= 7 && hour < 22)) ||
                            (timeRange === 'limited' && (hour >= limitedTimeRangeStart && hour < limitedTimeRangeEnd))
                    });


                    // Use map to create an array of Amount values from the filtered entries
                    const amounts = filteredData.map(entry => entry.Amount);

                    const roomData = {
                        roomName: room,
                        capacity: allRooms[room].capacity, // Access capacity from the object
                        observations: amounts  // List of people present in the room
                    };


                    generateTableForRoom(roomData, index);
                });
                // roomsData.forEach((room, index) => );


            }

            function generateMeasurementsTable(roomsMeasurements) {
                let totalMeasurements = 0;
                let rows = '';
                roomsMeasurements.forEach(room => {
                    rows += `<tr><td>${room.room}</td><td>${room.measurements}</td></tr>`;
                    totalMeasurements += room.measurements;
                });
                return `
                <table>
                    <thead>
                        <tr><th>Zaal bezetting</th><th>Aantal meetmomenten</th></tr>
                    </thead>
                    <tbody>
                        ${rows}
                        <tr><td><strong>Totaal</strong></td><td><strong>${totalMeasurements}</strong></td></tr>
                    </tbody>
                </table>
            `;
            }
            function generateOccupancyTable(occupancyData) {
                let totalMeasurements = 0;
                let totalOccupied = 0;
                let rows = '';

                occupancyData.forEach(item => {
                    const occupancyPercentage = (item.bezet / item.measurements * 100).toFixed(0);
                    rows += `<tr><td>${item.room}</td><td>${item.measurements}</td><td>${item.bezet}</td><td>${occupancyPercentage}%</td></tr>`;
                    totalMeasurements += item.measurements;
                    totalOccupied += item.bezet;
                });

                const totalOccupancyPercentage = (totalOccupied / totalMeasurements * 100).toFixed(0) + '%';

                return `
                <table>
                    <thead>
                        <tr>
                            <th>Zaal</th>
                            <th>Aantal meetmomenten</th>
                            <th>Aantal bezet</th>
                            <th>% Bezet</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                        <tr><td><strong>Totaal</strong></td><td><strong>${totalMeasurements}</strong></td><td><strong>${totalOccupied}</strong></td><td><strong>${totalOccupancyPercentage}</strong></td></tr>
                    </tbody>
                </table>
            `;
            }

            const timeInputs = document.querySelectorAll('input[name="timeRange"]');
            timeInputs.forEach(input => {
                input.addEventListener('change', function () {
                    if (data) { // Check if data is loaded
                        generateTables();
                        generateAllLineBezettingPlots();
                        generateAllLineBenuttingPlots();
                        generateRoosterGraadFigure();
                    }
                });
            });






            function wrapText(text, maxLength) {
                const words = text.split(' ');
                let wrappedText = '';
                let line = '';

                words.forEach((word) => {
                    if ((line + word).length <= maxLength) {
                        line += (line ? ' ' : '') + word;
                    } else {
                        wrappedText += line + '<br>';
                        line = word;
                    }
                });

                return wrappedText + line;
            }

            function data2traces(data) {

                const rooms = [...new Set(data.map(row => row.RoomName))].sort();
                const times = [...new Set(data.map(row => row.Time))].sort();
                const days = [...new Set(data.map(row => row.EventDay))].sort();

                const weekdays = all_days_of_week; // to keep sorting, can choose monday as first day here
                let typesAllKeys = [rooms, times, days, weekdays];

                let aggregates = {}

                // initialize aggreta object
                types.forEach((type, i) => {
                    aggregates[type] = { all_sorted: typesAllKeys[i], data: {} }
                    typesAllKeys[i].forEach(key => {
                        aggregates[type].data[key] = {
                            scheduledNotEmpty: 0,
                            scheduledEmpty: 0,
                            notScheduledNotEmpty: 0,
                            notScheduledEmpty: 0,
                        };
                    })
                })

                data.forEach(row => {
                    // logic to find the fields that should be increased
                    scheduledNotEmpty = row.EventId && row.Amount > 0 ? 1 : 0;
                    scheduledEmpty = row.EventId && row.Amount == 0 ? 1 : 0;
                    notScheduledNotEmpty = !row.EventId && row.Amount > 0 ? 1 : 0;
                    notScheduledEmpty = !row.EventId && row.Amount == 0 ? 1 : 0;

                    keys = [row.RoomName, row.Time, row.EventDay, row.weekday];
                    types.forEach((type, i) => {
                        count = 0;
                        types.forEach((check_type, k) => {
                            // scary logic to apply selection, if in selction or if the field is the current field or should be non-empty, 
                            if (selected[k].includes(keys[k]) || i == k || selected[k].length == 0) {
                                count += 1;
                            }
                        })
                        if (count == 4) { // passed all filters
                            aggregates[type].data[keys[i]].scheduledNotEmpty += scheduledNotEmpty
                            aggregates[type].data[keys[i]].scheduledEmpty += scheduledEmpty
                            aggregates[type].data[keys[i]].notScheduledNotEmpty += notScheduledNotEmpty
                            aggregates[type].data[keys[i]].notScheduledEmpty += notScheduledEmpty
                        }
                    })
                })

                const colors = ["#4472c4", "#ed7d31", "#a5a5a5", "#ffc000"];
                const labels = ["Wel geroosterd & bezet", "Wel geroosterd & niet bezet", "Niet geroosterd & wel bezet", "Niet geroosterd & niet bezet"];

                var oneDay = 24 * 60 * 60 * 1000;
                let widths = [0.8, 1, oneDay, 0.8];

                let allTraces = {};
                types.forEach(type => allTraces[type] = []);

                types.forEach((type, j) => {
                    plot_obj = aggregates[type];
                    width = widths[j];
                    plot_obj.all_sorted.forEach(key => {
                        const scheduledNotEmpty = plot_obj.data[key].scheduledNotEmpty;
                        const scheduledEmpty = plot_obj.data[key].scheduledEmpty;
                        const notScheduledNotEmpty = plot_obj.data[key].notScheduledNotEmpty;
                        const notScheduledEmpty = plot_obj.data[key].notScheduledEmpty;

                        const dataToPlot = [scheduledNotEmpty, scheduledEmpty, notScheduledNotEmpty, notScheduledEmpty];
                        const total = dataToPlot.reduce((acc, val) => acc + val, 0);
                        const percentageData = dataToPlot.map(val => total != 0 ? (val / total) : 0); // avoid divide by zero


                        percentageData.forEach((percentage, i) => {
                            if (!allTraces[type][i]) {
                                allTraces[type][i] = {
                                    x: [],
                                    y: [],
                                    name: labels[i],
                                    type: 'bar',
                                    marker: { color: colors[i] },
                                    width: width,
                                    hoverinfo: 'y', // Show only the value on hover
                                };
                            }

                            if (type === "rooms") {
                                wrappedRoom = wrapText(key, 15);
                                allTraces[type][i].x.push(wrappedRoom);
                            }
                            else {
                                allTraces[type][i].x.push(key);

                            }
                            allTraces[type][i].y.push(percentage);
                        });
                    });
                })
                return allTraces

            }

            function plot(allTraces) {


                types.forEach((type, i) => {
                    layouts[type] = {
                        // title: type,
                        barmode: 'stack',
                        xaxis: {
                            tickangle: -45,
                        },

                        yaxis: {
                            // title: 'Percentage (%)',
                            tickformat: ',.0%',
                        },
                        showlegend: false,
                        dragmode: 'select',
                        selectdirection: 'h',
                        margin: {
                            l: 40, r: 10, t: 10, b: 70
                        },
                    };


                    Plotly.newPlot('plot' + i, allTraces[type], layouts[type], {responsive: true}).then(() => {
                        const plotDiv = document.getElementById('plot' + i);
                        plotDiv.on('plotly_selected', (event) => handleSelection(event, i));
                    });
                })
            }


            function generateAllLineBezettingPlots() {
                const timeRange = document.querySelector('input[name="timeRange"]:checked').value;

                rooms = [...new Set(data.map(row => row.RoomName))].sort();
                times = [...new Set(data.map(row => row.hour))].sort(x => parseInt(x));
                times = times.filter(time => (timeRange === 'full' && (time >= 7 && time < 22)) ||
                    (timeRange === 'limited' && (time >= limitedTimeRangeStart && time < limitedTimeRangeEnd)));
                weekdays = all_days_of_week;

                numBezetTime = rooms.map(room => times.map(time => 0));
                numNietBezetTime = rooms.map(room => times.map(time => 0));
                numTotalTime = rooms.map(room => times.map(time => 0));

                numBezetWeekday = rooms.map(room => weekdays.map(weekday => 0));
                numNietBezetWeekday = rooms.map(room => weekdays.map(weekday => 0));
                numTotalWeekday = rooms.map(room => weekdays.map(weekday => 0));

                sumBezetAllRoomsTime = times.map(time => 0);
                sumTotalAllRoomsTime = times.map(time => 0);
                sumBezetAllRoomsWeekday = weekdays.map(weekday => 0);
                sumTotalAllRoomsWeekday = weekdays.map(weekday => 0);

  
                data.forEach(row => {
                    const hour = row.DateTime.getHours();
                    if ((timeRange === 'full' && (hour >= 7 && hour < 22)) ||
                        (timeRange === 'limited' && (hour >= limitedTimeRangeStart && hour < limitedTimeRangeEnd))) {
                        room = row.RoomName;
                        time = row.hour;
                        weekday = row.weekday;
                        i = rooms.indexOf(room);
                        j = times.indexOf(time);
                        k = weekdays.indexOf(weekday);
                        if (row.Amount > 0) {
                            numBezetTime[i][j] += 1;
                            numBezetWeekday[i][k] += 1;

                            sumBezetAllRoomsTime[j] += 1;
                            sumBezetAllRoomsWeekday[k] += 1;
                        } else {
                            numNietBezetTime[i][j] += 1;
                            numNietBezetWeekday[i][k] += 1;
                        }
                        numTotalTime[i][j] += 1;
                        numTotalWeekday[i][k] += 1;
                        sumTotalAllRoomsTime[j] += 1;
                        sumTotalAllRoomsWeekday[k] += 1;
                    }

                });
                

                hide = rooms.map(room => numTotalTime[rooms.indexOf(room)].reduce((a, b) => a + b, 0) < parseInt(0.1 * data.length / rooms.length));
                traceSumTime = {
                    x: times,
                    y: sumBezetAllRoomsTime.map((bezet, index) =>
                        sumTotalAllRoomsTime[index] > 0 ? (bezet / sumTotalAllRoomsTime[index]) * 100 : 0
                    ),
                    name: 'Gemiddelde bezetting',
                    type: 'scatter',
                    mode: 'lines',
                    
                    line: {
                        color: 'rgba(219, 64, 82, 100)',
                        width: 7,
                    },
                    opacity: 0.4 

                };
                traceSumWeekday = {
                    x: weekdays,
                    y: sumBezetAllRoomsWeekday.map((bezet, index) =>
                        sumTotalAllRoomsWeekday[index] > 0 ? (bezet / sumTotalAllRoomsWeekday[index]) * 100 : 0
                    ),
                    name: 'Gemiddelde bezetting',
                    type: 'scatter',
                    mode: 'lines',
                    
                    line: {
                        color: 'rgba(219, 64, 82, 100)',
                        width: 7,
                    },
                    opacity: 0.4 

                };

                tracesTime = [traceSumTime];
                tracesWeekday = [traceSumWeekday];
                
                for (i = 0; i < rooms.length; i++) {
                    normalizedBezetTime = numBezetTime[i].map((bezet, index) =>
                        numTotalTime[i][index] > 0 ? (bezet / numTotalTime[i][index]) * 100 : 0
                    );
                    normalizedBezetWeekday = numBezetWeekday[i].map((bezet, index) =>
                        numTotalWeekday[i][index] > 0 ? (bezet / numTotalWeekday[i][index]) * 100 : 0
                    );

                    traceTime = {
                        x: times,
                        y: normalizedBezetTime,
                        name: rooms[i],  
                        type: 'scatter',
                        mode: 'lines+markers',  
                        marker: {
                            size: 6  
                        }
                    };
                    traceWeekday = {
                        x: weekdays,
                        y: normalizedBezetWeekday,  
                        name: rooms[i],  
                        type: 'scatter',
                        mode: 'lines+markers',
                        marker: {
                            size: 6
                        }
                    };
                    if (hide[i]) {
                        traceTime.visible = 'legendonly';
                        traceWeekday.visible = 'legendonly';
                    }
                    tracesTime.push(traceTime);
                    tracesWeekday.push(traceWeekday);
                }

                
                layoutTime = {
                    title: 'Gemiddelde bezetting gedurende de dag per zaal',
                    xaxis: {
                        tickvals: times,
                        ticktext: times.map(time => `${time}:00`),  // format like 08:00, 09:00 etc.
                        showgrid: true  
                    },
                    yaxis: {
                        title: 'Bezetting (%)',
                        rangemode: 'tozero',
                        showgrid: true
                    },
                    legend: {
                        orientation: 'h',  // Horizontal legend
                        y: -0.25  // Position below the plot
                    },
                    margin: {
                        // l : 0,
                        r : 0,
                        t: 60,  
                        b: 0  
                    }
                };

                layoutWeekday = {
                    title: 'Gemiddelde bezetting gedurende de week per zaal',
                    xaxis: {
                        showgrid: true
                    },
                    yaxis: {
                        title: 'Bezetting (%)',
                        rangemode: 'tozero',
                        showgrid: true
                    },
                    legend: {
                        orientation: 'h',
                        y: -0.25
                    },
                    margin: {
                        r : 0,
                        t: 60,
                        b: 0
                    }
                };


                // Render the plots
                Plotly.newPlot('throughout-day-plot-rooms', tracesTime, layoutTime,{responsive: true});
                Plotly.newPlot('throughout-weekday-plot-rooms', tracesWeekday, layoutWeekday,{responsive: true});
            }

            function generateAllLineBenuttingPlots() {
                // similar to bezetting, but now we want to show the benutting
                // benutting = bezet / capaciteit if bezet > 0. So only counts when bezet > 0
                const timeRange = document.querySelector('input[name="timeRange"]:checked').value;
                rooms = [...new Set(data.map(row => row.RoomName))].sort();
                times = [...new Set(data.map(row => row.hour))].sort(x => parseInt(x));
                times = times.filter(time => (timeRange === 'full' && (time >= 7 && time < 22)) ||
                    (timeRange === 'limited' && (time >= limitedTimeRangeStart && time < limitedTimeRangeEnd)));
                weekdays = all_days_of_week;
                numBezetTime = rooms.map(room => times.map(time => 0));
                numBezetWeekday = rooms.map(room => weekdays.map(weekday => 0));
                numTotalTime = rooms.map(room => times.map(time => 0));
                numTotalWeekday = rooms.map(room => weekdays.map(weekday => 0));
                sumBezetAllRoomsTime = times.map(time => 0);
                sumTotalAllRoomsTime = times.map(time => 0);
                sumBezetAllRoomsWeekday = weekdays.map(weekday => 0);
                sumTotalAllRoomsWeekday = weekdays.map(weekday => 0);

                data.forEach(row => {
                    hour = row.DateTime.getHours();
                    if ((timeRange === 'full' && (hour >= 7 && hour < 22)) ||
                        (timeRange === 'limited' && (hour >= limitedTimeRangeStart && hour < limitedTimeRangeEnd))) {
                    room = row.RoomName;
                    time = row.hour;
                    capacity = parseInt(row.RoomCapacity);

                    weekday = row.weekday;
                    i = rooms.indexOf(room);
                    j = times.indexOf(time);
                    k = weekdays.indexOf(weekday);
                    if (row.Amount > 0) {
                        sumBezetAllRoomsTime[j] += 1;
                        sumBezetAllRoomsWeekday[k] += 1;

                        numBezetTime[i][j] += 1;
                        numBezetWeekday[i][k] += 1;
                    }
                    sumTotalAllRoomsTime[j] += parseInt(row.Amount) / capacity;
                    sumTotalAllRoomsWeekday[k] += parseInt(row.Amount) / capacity;
                    numTotalTime[i][j] += parseInt(row.Amount) / capacity;
                    numTotalWeekday[i][k] += parseInt(row.Amount) / capacity;
                }
                });
                console.log(numBezetWeekday, numBezetTime, numTotalTime, numTotalWeekday)
                hide = rooms.map(room => numBezetTime[rooms.indexOf(room)].reduce((a, b) => a + b, 0) < parseInt(0.1 * data.length / rooms.length));
                traceSumTime = {
                    x: times,
                    y: sumBezetAllRoomsTime.map((bezet, index) =>
                        (sumTotalAllRoomsTime[index] / bezet ) * 100 
                    ),
                    name: 'Gemiddelde benutting',
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: 'rgba(219, 64, 82, 100)',
                        width: 7,
                    },
                    opacity: 0.4 

                };
                traceSumWeekday = {
                    x: weekdays,
                    y: sumBezetAllRoomsWeekday.map((bezet, index) =>
                        (sumTotalAllRoomsWeekday[index]/bezet) * 100 
                    ),
                    name: 'Gemiddelde benutting',
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: 'rgba(219, 64, 82, 100)',
                        width: 7,
                    },
                    opacity: 0.4 

                };
                tracesTime = [traceSumTime];
                tracesWeekday = [traceSumWeekday];
                for (i = 0; i < rooms.length; i++) {
                    normalizedBezetTime = numBezetTime[i].map((bezet, index) =>
                        (numTotalTime[i][index] / bezet) * 100
                    );
                    normalizedBezetWeekday = numBezetWeekday[i].map((bezet, index) =>
                        (numTotalWeekday[i][index] / bezet) * 100
                    );
                    traceTime = {
                        x: times,
                        y: normalizedBezetTime,
                        name: rooms[i],  
                        type: 'scatter',
                        mode: 'lines+markers',  
                        marker: {
                            size: 6 
                        }
                    };
                    traceWeekday = {
                        x: weekdays,
                        y: normalizedBezetWeekday,  
                        name: rooms[i],  
                        type: 'scatter',
                        mode: 'lines+markers',
                        marker: {
                            size: 6
                        }
                    };
                    if (hide[i]) {
                        traceTime.visible = 'legendonly';
                        traceWeekday.visible = 'legendonly';
                    }
                    tracesTime.push(traceTime);
                    tracesWeekday.push(traceWeekday);
                }

                layoutTime = {
                    title: 'Gemiddelde benutting gedurende de dag per zaal als de zaal bezet is',
                    xaxis: {
                        // title: 'Tijd',
                        tickvals: times,
                        ticktext: times.map(time => `${time}:00`),  // format like 08:00, 09:00 etc.
                        showgrid: true  
                    },
                    yaxis: {
                        title: 'Benutting (%)',
                        rangemode: 'tozero',
                        showgrid: true
                    },
                    legend: {
                        orientation: 'h',  // Horizontal legend
                        y: -0.25  // Position below the plot
                    },
                    margin: {
                        r : 0,
                        t: 60,
                        b: 0
                    }
                };

                layoutWeekday = {
                    title: 'Gemiddelde benutting gedurende de week per zaal als de zaal bezet is',
                    xaxis: {
                        // title: 'Dag',
                        showgrid: true
                    },
                    yaxis: {
                        title: 'Benutting (%)',
                        rangemode: 'tozero',
                        showgrid: true
                    },
                    legend: {
                        orientation: 'h',
                        y: -0.25
                    },
                    margin: {
                        r : 0,
                        t: 60,
                        b: 0
                    }
                };
                // Render the plots
                Plotly.newPlot('throughout-day-plot-rooms-benutting', tracesTime, layoutTime,{responsive: true});
                Plotly.newPlot('throughout-weekday-plot-rooms-benutting', tracesWeekday, layoutWeekday,{responsive: true});

            }

            function generateRoosterGraadFigure(){
                const timeRange = document.querySelector('input[name="timeRange"]:checked').value;

                // this function calculates the amount of time that there's an eventID for a room
                // and plots this as a bar graph with a bar for each room

                rooms = [...new Set(data.map(row => row.RoomName))].sort();
                numRoosterGraad = rooms.map(room => 0);
                numTotalTime = rooms.map(room => 0);

                data.forEach(row => {
                    hour = row.DateTime.getHours();
                    if ((timeRange === 'full' && (hour >= 7 && hour < 22)) ||
                        (timeRange === 'limited' && (hour >= limitedTimeRangeStart && hour < limitedTimeRangeEnd))) {
                    room = row.RoomName;
                    i = rooms.indexOf(room);

                    if (row.EventId) {
                        numRoosterGraad[i] += 1;
                    }
                    numTotalTime[i] += 1;
                }
                });
                normalizedRoosterGraad = numRoosterGraad.map((roosterGraad, index) =>
                    numTotalTime[index] > 0 ? (roosterGraad / numTotalTime[index]) * 100 : 0
                );
                traces = [];
                for (i = 0; i < rooms.length; i++) {
                    trace = {
                        x: [rooms[i]],
                        y: [normalizedRoosterGraad[i]],
                        name: rooms[i],  
                        type: 'bar',
                    };
                    traces.push(trace);
                }

                averageRoosterGraad = numRoosterGraad.reduce((a, b) => a + b, 0) / numTotalTime.reduce((a, b) => a + b, 0) * 100;
                traces.push({
                    x: rooms,
                    y: rooms.map(room => averageRoosterGraad),
                    name: 'Gemiddelde',
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        dash: 'dash'
                    }
                });
                
                layout = {
                    title: 'Roostergraad per ruimte',
                    xaxis: {
                        showgrid: true
                    },
                    yaxis: {
                        title: 'Roostergraad (%)',
                        rangemode: 'tozero',
                        showgrid: true
                    },
                };
                Plotly.newPlot('rooster-graad-plot', traces, layout,{responsive: true});
            }


            function calculateHistogram(observations, capacity) {
                const histogram = Array(10).fill(0); // 10 deciles (0-10%, 10-20%, ..., 90-100%)

                observations.forEach(people => {
                    const percentage = (people / capacity) * 100;
                    const decileIndex = Math.min(Math.floor(percentage / 10), 9); // Ensure max decile is 90-100%
                    histogram[decileIndex]++;
                });

                return histogram;
            }

            // Function to convert the histogram into integer percentages that sum to 100
            function calculateIntegerPercentages(histogram, totalObservations) {
                let percentages = histogram.map(count => Math.round((count / totalObservations) * 100));

                // Adjust the percentages to ensure they sum to 100
                let totalPercentage = percentages.reduce((sum, val) => sum + val, 0);
                while (totalPercentage !== 100) {
                    let index = totalPercentage > 100 ? percentages.indexOf(Math.max(...percentages)) : percentages.indexOf(Math.min(...percentages));
                    percentages[index] += totalPercentage > 100 ? -1 : 1;
                    totalPercentage = percentages.reduce((sum, val) => sum + val, 0);
                }

                return percentages;
            }

            // Function to generate a table and description for each room
            function generateTableForRoom(roomData, index) {
                const roomTablesDiv = document.getElementById('roomTables');

                // Figure numbering (III.a, III.b, etc.)
                const figureLetter = String.fromCharCode(97 + index); // Convert index to 'a', 'b', 'c', etc.

                // Create room description
                const roomInfo = document.createElement('div');
                roomInfo.className = 'room-info';
                roomInfo.innerText = `Figure III.${figureLetter}: Benutting in categorieën ${roomData.roomName}, capaciteit: ${roomData.capacity}`;

                // Create the table
                const table = document.createElement('table');
                table.style = "margin-bottom: 0px;"
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                // Table headers
                thead.innerHTML = `
        <tr>
            <th rowspan="2">Ruimte</th>
            <th colspan="2" class="absolute">Absolute getallen bezetting</th>
            <th colspan="10" class="decielen">Bezetting in decielen (t.o.v. capaciteit)</th>
            <th rowspan="2">Totaal</th>
        </tr>
        <tr>
            <th>0 personen (no show)</th>
            <th>1-3 personen</th>
            <th>0-10%</th>
            <th>10-20%</th>
            <th>20-30%</th>
            <th>30-40%</th>
            <th>40-50%</th>
            <th>50-60%</th>
            <th>60-70%</th>
            <th>70-80%</th>
            <th>80-90%</th>
            <th>90-100%</th>
        </tr>
    `;
                table.appendChild(thead);

                // Calculate histogram and percentages
                const histogram = calculateHistogram(roomData.observations, roomData.capacity);
                const percentages = calculateIntegerPercentages(histogram, roomData.observations.length);

                // Calculate percentages for no show and 1-3 people
                const totalObservations = roomData.observations.length;
                const noShowPercentage = (roomData.observations.filter(o => o === 0).length / totalObservations * 100).toFixed(0);
                const oneToThreePercentage = (roomData.observations.filter(o => o > 0 && o <= 3).length / totalObservations * 100).toFixed(0);

                // Table body (room data)
                const row = document.createElement('tr');
                row.innerHTML = `
        <td>${roomData.roomName}</td>
        <td>${noShowPercentage}%</td>
        <td>${oneToThreePercentage}%</td>
        <td>${percentages[0]}%</td>
        <td>${percentages[1]}%</td>
        <td>${percentages[2]}%</td>
        <td>${percentages[3]}%</td>
        <td>${percentages[4]}%</td>
        <td>${percentages[5]}%</td>
        <td>${percentages[6]}%</td>
        <td>${percentages[7]}%</td>
        <td>${percentages[8]}%</td>
        <td>${percentages[9]}%</td>
        <td>100%</td>
    `;
                tbody.appendChild(row);

                table.appendChild(tbody);

                roomTablesDiv.appendChild(table);

                roomTablesDiv.appendChild(roomInfo);

            }

            // Generate tables for all rooms, passing the index for figure numbering




        </script>
</body>

</html>
